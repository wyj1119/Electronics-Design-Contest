/* --COPYRIGHT--,BSD
 * Copyright (c) 2017, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * --/COPYRIGHT--*/
/******************************************************************************
 * MSP432E4 Example project for ADC with multiple channel and single sequencer
 * with Timer Trigger and DMA Request from ADC.
 *
 * Description: In this application example the ADC0 is configured for a single
 * sequencer sampling 4 channels in single ended mode. The ADC is triggered by
 * a timer running in periodic mode with a sampling frequency of 1 KHz. After
 * the conversion is completed a DMA request is generated by the ADC Sequencer.
 * The data is read by the DMA and an interrupt request to the CPU is
 * generated. The CPU reads the data from the DMA buffer and re-enables the
 * DMA to transfer more data.
 *
 *                MSP432E401Y
 *             ------------------
 *         /|\|               PE3|<-- AIN0
 *          | |               PE2|<-- AIN1
 *          --|RST            PE1|<-- AIN2
 *            |               PE0|<-- AIN3
 *            |                  |
 *            |                  |
 *            |               PA0|<--U0RX
 *            |               PA1|-->U0TX
 * Author: Amit Ashara
*******************************************************************************/
/* DriverLib Includes */
#include <ti/devices/msp432e4/driverlib/driverlib.h>

/* Standard Includes */


/* Display Include via console */
#include "delay.h"
#include "math.h"
#include "tim_counter.h"
#include "my_math.h"
#include "my_usart.h"
#include  "AD9833.h"
#include "measure_z.h"
#include "tim_10k_1k_90d.h"
#include "adc_fft.h"
#include "measure_z.h"
#define Fs 500000


int16_t adc0_buffer_0[BUFFER_SIZE];
int16_t adc0_buffer_1[BUFFER_SIZE];

int16_t adc2_buffer_0[BUFFER_SIZE];
int16_t adc2_buffer_1[BUFFER_SIZE];

#define SWEEP_BUF_LENGTH 60
int16_t sweep_buf[600];

msp_fft_q15_params params;


ADC_FFT_Structure ADC0_FFT_Str;
ADC_FFT_Structure ADC2_FFT_Str;

uint8_t bgetConvStatus = 0;//ADC_INT  0--无数据 1--第一个buffer满  2--第二个buffer满
uint8_t bgetConvStatus_adc1 = 0;

MEASURE_Z_Structure MEASURE_Z_Str;
uint8_t flag_measure = 0;



float ratio_U1_U2[3]={0};//每次测量先算三次fft, 决定用什么挡位测量
uint8_t close_ratio_idx=0;

void show_array_u16(uint16_t *arr,uint32_t length)
{
    uint16_t i=0;
    for(i=0;i<length;i++)
    {
        USART_printf(UART0_BASE,"%u\r\n",arr[i]);

    }
}
void show_array_i16(int16_t *arr,uint32_t length)
{
    uint16_t i=0;
    for(i=0;i<length;i++)
    {
        USART_printf(UART0_BASE,"%d\r\n",arr[i]);

    }
}
void Init_LED(void)
{
    MAP_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPION);
    while(!(SysCtlPeripheralReady(SYSCTL_PERIPH_GPION)))
    {

    }

    /* Configure the GPIO PN0-PN1 as output */
    MAP_GPIOPinTypeGPIOOutput(GPIO_PORTN_BASE, (GPIO_PIN_0 | GPIO_PIN_1));
    MAP_GPIOPinWrite(GPIO_PORTN_BASE, (GPIO_PIN_0 | GPIO_PIN_1), 0);
}

#define R_5K_REAL_VAL 5178
#define R_10K_REAL_VAL 10067
#define R_100K_REAL_VAL 101868

#define C_MEASURE_F 1000



void start_measure_one_time(uint32_t fs)
{
    set_Fs(fs,0);
    MAP_TimerEnable(TIMER0_BASE, TIMER_A);
    while(1)
    {
        if(bgetConvStatus==1 && bgetConvStatus_adc1==1)
        {
            MAP_TimerDisable(TIMER0_BASE, TIMER_A);
            bgetConvStatus=0;
            bgetConvStatus_adc1=0;

            MAP_TimerEnable(TIMER0_BASE, TIMER_A);
        }
        else if(bgetConvStatus==2 && bgetConvStatus_adc1==2)
        {
            MAP_TimerDisable(TIMER0_BASE, TIMER_A);
            bgetConvStatus=0;
            bgetConvStatus_adc1=0;
            break;
        }
    }
}




void choose_channel_C(void)
{
    uint32_t i=0;
    float temp_data=1e9;

    uint16_t u1_buf[3]={0};
    uint16_t u2_buf[3]={0};

    uint16_t max_val_u1=0;
    uint16_t min_val_u1=0xffff;
    uint16_t max_idx_u1=0;
    uint16_t min_idx_u1=0;

    uint16_t max_val_u2=0;
    uint16_t min_val_u2=0xffff;
    uint16_t max_idx_u2=0;
    uint16_t min_idx_u2=0;

    int8_t score_buf[2][3]={0};
    int8_t score_res[3]={0};

    uint8_t max_score_res=0;
    uint8_t max_score_res_idx=0;
    uint8_t equl_idx=100;

    for(i=0;i<3;i++)
    {
        switch(i)
        {
            case 0:SWITCH_5K;break;
            case 1:SWITCH_10K;break;
            case 2:SWITCH_100K;break;
        }

        start_measure_one_time(40000);
        cal_fft(&params,adc0_buffer_1,&ADC0_FFT_Str,1);
        cal_fft(&params,adc2_buffer_1,&ADC2_FFT_Str,1);

        u1_buf[i] = ADC0_FFT_Str.RMS;
        u2_buf[i] = ADC2_FFT_Str.RMS;

        if(ADC0_FFT_Str.RMS > ADC2_FFT_Str.RMS)
        {
            ratio_U1_U2[i] =1.0f - ADC0_FFT_Str.RMS / (float)ADC2_FFT_Str.RMS;
        }
        else
        {
            ratio_U1_U2[i] =1.0f - ADC2_FFT_Str.RMS / (float)ADC0_FFT_Str.RMS;
        }

        if(ratio_U1_U2[i]<0)
            ratio_U1_U2[i]=-ratio_U1_U2[i];
    }
    temp_data = 1e9;
    for(i=0;i<3;i++)
    {
        if( ratio_U1_U2[i] < temp_data )
        {
            temp_data =  ratio_U1_U2[i];
            close_ratio_idx = i;
        }

        if( u1_buf[i]>max_val_u1 )
        {
            max_val_u1=u1_buf[i];
            max_idx_u1=i;
        }
        if( u1_buf[i]<min_val_u1 )
        {
            min_val_u1=u1_buf[i];
            min_idx_u1=i;
        }
        if( u2_buf[i]>max_val_u2 )
        {
            max_val_u2=u2_buf[i];
            max_idx_u2=i;
        }
        if( u2_buf[i]<min_val_u2 )
        {
            min_val_u2=u2_buf[i];
            min_idx_u2=i;
        }
    }

    score_buf[0][max_idx_u1] = 1;
    score_buf[0][min_idx_u1] = -1;
    score_buf[1][max_idx_u2] = 1;
    score_buf[1][min_idx_u2] = -1;


    for(i=0;i<3;i++)
    {
        score_res[i] = score_buf[0][i] + score_buf[1][i];
    }

    for(i=0;i<3;i++)
    {
        if(score_res[i] > max_score_res)
        {
             max_score_res = score_res[i];
             max_score_res_idx = i;
        }
        else if(score_res[i] == max_score_res)
        {
            equl_idx = i;
        }
    }

    if(equl_idx==100)
        close_ratio_idx = max_score_res_idx;//没有相同的值

    switch(close_ratio_idx)
    {
        case 0:SWITCH_5K;break;
        case 1:SWITCH_10K;break;
        case 2:SWITCH_100K;break;
    }
    USART_printf(UART0_BASE,"choose channel : %u\r\n",close_ratio_idx);

    //换挡函数
}



void Mea_RMS_C(void)
{
    start_measure_one_time(40000);
    cal_fft(&params,adc0_buffer_1,&ADC0_FFT_Str,1);
    cal_fft(&params,adc2_buffer_1,&ADC2_FFT_Str,1);
}


void Mea_Phase_C(void)
{
    uint32_t i=0;

   for(i=0;i<MEASURE_TIMES;i++)
   {
       start_measure_one_time(500000);
       get_Phase_C((uint16_t*)adc0_buffer_1,(uint16_t*)adc2_buffer_1,&MEASURE_Z_Str);
   }
}


void Cal_C(void)
{
    switch(close_ratio_idx)
  {
      case 0:
      {
          get_C(ADC0_FFT_Str.RMS,
               ADC2_FFT_Str.RMS,
               R_5K_REAL_VAL,
               1000,
             &MEASURE_Z_Str,1);

      }break;
      case 1:
      {
       get_C(ADC0_FFT_Str.RMS,
             ADC2_FFT_Str.RMS,
             R_10K_REAL_VAL,
             1000,
            &MEASURE_Z_Str,1);
      }break;
      case 2:
      {
     get_C(ADC0_FFT_Str.RMS,
           ADC2_FFT_Str.RMS,
           R_100K_REAL_VAL,
           1000,
          &MEASURE_Z_Str,1);
      }break;
  }
}


void Mea_Phase_L(void)
{
    uint32_t i=0;

   for(i=0;i<MEASURE_TIMES;i++)
   {
       start_measure_one_time(500000);
       get_Phase_L((uint16_t*)adc0_buffer_1,(uint16_t*)adc2_buffer_1,&MEASURE_Z_Str);
   }
}



void Mea_RMS_L(uint32_t fs)
{
    start_measure_one_time(fs);
    cal_fft(&params,adc0_buffer_1,&ADC0_FFT_Str,0);
}

#define C_parallel (980.5*1e-9)
#define R_serial (50.8)
void sweep_fre(void)
{
    uint32_t i=0;

    uint32_t max_idx=0;
    uint16_t max_val=0;

    for(i=1;i<=600;i++)
    {
        AD9833_Default_Set(i*100);//测电感时使用的频率
        Mea_RMS_L(500000);
        sweep_buf[i] = ADC0_FFT_Str.RMS;


        if(sweep_buf[i]>max_val)
        {
            max_idx = i;
            max_val = sweep_buf[i];
        }

//        USART_printf(UART0_BASE,"%u\r\n",sweep_buf[i]);
    }

    MEASURE_Z_Str.f_LC = max_idx*100;

    MEASURE_Z_Str.L = 1.0f/(4.0f*PI*PI*C_parallel*MEASURE_Z_Str.f_LC*MEASURE_Z_Str.f_LC);

    MEASURE_Z_Str.Q = 1.0f/R_serial*sqrtf(MEASURE_Z_Str.L / C_parallel);

    AD9833_Default_Set(10000);//测电感时使用的频率
//    USART_printf(UART0_BASE,"F_LC = %f,L = %f\r\n",MEASURE_Z_Str.f_LC,MEASURE_Z_Str.L*1e6);

}

int main(void)
{

    uint32_t systemClock;
    int temp =0;
    /* Configure the system clock for 120 MHz */
    systemClock = MAP_SysCtlClockFreqSet((SYSCTL_XTAL_25MHZ | SYSCTL_OSC_MAIN |
                                          SYSCTL_USE_PLL | SYSCTL_CFG_VCO_480),
                                          120000000);
    delay_init();
    Init_LED();

    ConfigureUART0_debug(systemClock);
    ConfigureUART7_screen(systemClock);
    USART_printf(UART7_BASE,"\x00\xff\xff\xff");//初始化串口屏

    Init_Switch_GPIO();
    SWITCH_5K;
    Init_Timer_PWM_1k_90_d();

    AD9833_Init_GPIO();
    AD9833_Init();
    AD9833_Default_Set(1000);
    AD9833_Set_Amplitude(430);
    Init_adc0_dma((int16_t*)adc0_buffer_0);//Seq 2 PE3 //同步
    Init_adc2_dma((int16_t*)adc2_buffer_0);//Seq 3 PE2 // 同步

    Init_fft(&params);

    adc01_tim_config(Fs);

    /* Wait loop */
    while(1)
    {
        if(flag_measure==1)
        {

        if(MEASURE_Z_Str.rec_cmd == 0x01)
        {
            SWITCH_MEASURE_C;
//关闭串口屏的电感显示
            USART_printf(UART7_BASE,"page1.x2.val=%d\xff\xff\xff",0);
            USART_printf(UART7_BASE,"page1.x3.val=%d\xff\xff\xff",0);

            AD9833_Default_Set(1000);//测电容时使用的频率
//===============================================================================================
            choose_channel_C();
//===============================================================================================
//=============================================测RMS==================================================
            Mea_RMS_C();
//==================================================================================================
//=============================================测相=====================================================
            Mea_Phase_C();
//====================================================================================================
            Cal_C();
            temp = MEASURE_Z_Str.C*100;
            USART_printf(UART7_BASE,"page1.x0.val=%d\xff\xff\xff",temp);
            temp = MEASURE_Z_Str.D*1000;
            USART_printf(UART7_BASE,"page1.x1.val=%d\xff\xff\xff",temp);//电容D值，三位小数，传输时*1000
            USART_printf(UART0_BASE,"page1.x1.val=%d\xff\xff\xff",(int)(MEASURE_Z_Str.D*1000));//电容D值，三位小数，传输时*1000
            bgetConvStatus=0;
            bgetConvStatus_adc1=0;
            flag_measure = 0;
        }


//===============================================================测电感=========================================================================
        else if(MEASURE_Z_Str.rec_cmd == 0x02)
        {
            //关闭串口屏的电感显示
            USART_printf(UART7_BASE,"page1.x0.val=%d\xff\xff\xff",0);
            USART_printf(UART7_BASE,"page1.x1.val=%d\xff\xff\xff",0);
            SWITCH_L;

            sweep_fre();
            temp = (MEASURE_Z_Str.L)*1e8;
            USART_printf(UART7_BASE,"page1.x2.val=%d\xff\xff\xff",temp);
            USART_printf(UART0_BASE,"page1.x2.val=%d\xff\xff\xff",temp);//电感Q值，三位小数，传输时*1000

            temp = (MEASURE_Z_Str.Q)*1000;
            USART_printf(UART7_BASE,"page1.x3.val=%d\xff\xff\xff",temp*98.647);//电感Q值uH，三位小数，传输时*1000
            USART_printf(UART0_BASE,"page1.x3.val=%d\xff\xff\xff",temp*98.647);//电感Q值，三位小数，传输时*1000

            bgetConvStatus=0;
            bgetConvStatus_adc1=0;
            flag_measure = 0;
          }
        }
    }
}


void ADC0SS2_IRQHandler(void)
{
    static uint8_t buffer_idx=0;
    uint32_t getIntStatus;
    int16_t *p=NULL;
    MAP_TimerDisable(TIMER0_BASE, TIMER_A);

    /* Get the interrupt status from the ADC */
    getIntStatus = MAP_ADCIntStatusEx(ADC0_BASE, true);

    /* If the interrupt status for Sequencer-2 is set the
     * clear the status and read the data */
    if((getIntStatus & ADC_INT_DMA_SS2) == ADC_INT_DMA_SS2)
    {
        /* Clear the ADC interrupt flag. */
        MAP_ADCIntClearEx(ADC0_BASE, ADC_INT_DMA_SS2);

        if(buffer_idx==0)
        {
            if(bgetConvStatus==0)
            {
                p=adc0_buffer_1;
                buffer_idx=1;
                bgetConvStatus = 1;
                MAP_uDMAChannelTransferSet(UDMA_CH16_ADC0_2 | UDMA_PRI_SELECT,
                                                          UDMA_MODE_BASIC,
                                                          (void *)&ADC0->SSFIFO2, (void *)p,
                                                          sizeof(adc0_buffer_0)/2);
                MAP_uDMAChannelEnable(UDMA_CH16_ADC0_2);
            }
            else
                MAP_TimerDisable(TIMER0_BASE, TIMER_A);
                /*USART_printf(UART0_BASE,"DMA_buzy1")*/;

        }
        else if(buffer_idx==1)
        {

            if(bgetConvStatus==0)
            {
                 bgetConvStatus = 2;
                 p=adc0_buffer_0;
                 buffer_idx=0;
                 MAP_uDMAChannelTransferSet(UDMA_CH16_ADC0_2 | UDMA_PRI_SELECT,
                                                           UDMA_MODE_BASIC,
                                                           (void *)&ADC0->SSFIFO2, (void *)p,
                                                           sizeof(adc0_buffer_0)/2);
                 MAP_uDMAChannelEnable(UDMA_CH16_ADC0_2);
            }
            else
                MAP_TimerDisable(TIMER0_BASE, TIMER_A);
                 /*USART_printf(UART0_BASE,"DMA_buzy2")*/;
        }
    }

}


void ADC1SS3_IRQHandler(void)
{
    static uint8_t buffer_idx_1=0;
    int16_t *p=NULL;

    uint32_t getIntStatus;
    MAP_TimerDisable(TIMER0_BASE, TIMER_A);
    /* Get the interrupt status from the ADC */
    getIntStatus = MAP_ADCIntStatusEx(ADC1_BASE, true);

    /* If the interrupt status for Sequencer-2 is set the
     * clear the status and read the data */
    if((getIntStatus & ADC_INT_DMA_SS3) == ADC_INT_DMA_SS3)
    {
        /* Clear the ADC interrupt flag. */
        MAP_ADCIntClearEx(ADC1_BASE, ADC_INT_DMA_SS3);


        if(buffer_idx_1==0)
        {
            if(bgetConvStatus_adc1==0)
            {
                p=adc2_buffer_1;
                buffer_idx_1 = 1;
                bgetConvStatus_adc1 = 1;
                MAP_uDMAChannelTransferSet(UDMA_CH27_ADC1_3 | UDMA_PRI_SELECT,
                                                           UDMA_MODE_BASIC,
                                                           (void *)&ADC1->SSFIFO3, (void *)p,
                                                           sizeof(adc2_buffer_1)/2);

                MAP_uDMAChannelEnable(UDMA_CH27_ADC1_3);
            }
            else
                MAP_TimerDisable(TIMER0_BASE, TIMER_A);
                /*USART_printf(UART0_BASE,"DMA_buzy1")*/;
        }
        else if(buffer_idx_1==1)
        {

            if(bgetConvStatus_adc1==0)
            {
                bgetConvStatus_adc1 = 2;
                 p=adc2_buffer_0;
                 buffer_idx_1=0;
                 MAP_uDMAChannelTransferSet(UDMA_CH27_ADC1_3 | UDMA_PRI_SELECT,
                                                                            UDMA_MODE_BASIC,
                                                                            (void *)&ADC1->SSFIFO3, (void *)p,
                                                                            sizeof(adc2_buffer_1)/2);

                 MAP_uDMAChannelEnable(UDMA_CH27_ADC1_3);
            }
            else
                MAP_TimerDisable(TIMER0_BASE, TIMER_A);
                 /*USART_printf(UART0_BASE,"DMA_buzy2")*/;
        }





    }
}

void UART7_IRQHandler(void)
{
    uint32_t ui32Status;
    uint8_t rec_temp=0;
    static uint8_t sta=0;
    static uint8_t rec_cmd_temp=0;
    //
    // Get the interrrupt status.
    //
    ui32Status = MAP_UARTIntStatus(UART7_BASE, true);

    //
    // Clear the asserted interrupts.
    //
    MAP_UARTIntClear(UART7_BASE, ui32Status);

    //
    // Loop while there are characters in the receive FIFO.
    //
    while(MAP_UARTCharsAvail(UART7_BASE))
    {
        //
        // Read the next character from the UART and write it back to the UART.
        //
        rec_temp = MAP_UARTCharGetNonBlocking(UART7_BASE);

        switch(sta)
        {
            case 0:
                if(rec_temp==0x55)sta=1;break;
            case 1:
            {
                rec_cmd_temp = rec_temp;
                sta=2;
            }break;
            case 2:
            {
                if(rec_temp==0xff)
                {
                     MEASURE_Z_Str.rec_cmd=rec_cmd_temp;
                     USART_printf(UART0_BASE,"cmd_rec = %x\r\n",MEASURE_Z_Str.rec_cmd);
                     if( flag_measure == 0)
                         flag_measure = 1;
                }
                else
                {
                    USART_printf(UART0_BASE,"cmd_Error!!!\r\n");
                }
                sta=0;
            }break;
        }
        //
        // Delay for 1 millisecond.  Each SysCtlDelay is about 3 clocks.
        //
        delay_ms(1);
    }

}


